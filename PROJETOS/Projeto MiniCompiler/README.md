# üõ†Ô∏è Projeto MiniCompiler

Bem-vindo ao **MiniCompiler** ‚Äî um projeto educacional simples criado para introduzir os conceitos b√°sicos de **compiladores** para estudantes de Engenharia de Software da PUC Minas que participam das oficinas de python do DevLabs.

---

## üéØ Objetivo do Projeto

Este mini compilador tem como objetivo **reconhecer senten√ßas simples de programas em uma linguagem C-like**, evoluindo em duas vers√µes v1 e v2.

Ele realiza duas etapas fundamentais da compila√ß√£o: **an√°lise l√©xica** e **an√°lise sint√°tica**.

---

### ‚úÖ Vers√£o 1 ‚Äì Analisador L√©xico + Sint√°tico (Declara√ß√µes)

Realiza:
- **An√°lise l√©xica:** quebra o c√≥digo em tokens v√°lidos  
- **An√°lise sint√°tica:** valida senten√ßas de **declara√ß√£o de vari√°veis**

Tokens reconhecidos:
- Palavras-chave: `int`, `float`  
- Operadores: `=`  
- Identificadores e n√∫meros  
- `;` (ponto e v√≠rgula)

**Exemplo v√°lido:**

```c
int x = 42;
float y = 3.14;
```

---

### ‚úÖ Vers√£o 2 ‚Äì Analisador L√©xico + Sint√°tico (Comandos de controle)

Amplia a an√°lise para reconhecer:
- Blocos (`{}`)  
- Comando `if` com express√£o condicional  
- Comando `while` com express√£o condicional

**Exemplo v√°lido:**

```c
int x = 5;
if (x > 0) {
    float y = 3.14;
}
```

**Exemplo inv√°lido (erro sint√°tico ‚Äì bloco n√£o fechado):**

```c
int x = 5;
if (x > 0) {
    float y = 3.14;
```

---

### üîç Componentes

- **Analisador L√©xico:** usa express√µes regulares para extrair tokens
- **Analisador Sint√°tico:** estrutura o c√≥digo e valida regras gramaticais simples

---

### üöß Limita√ß√µes

- N√£o reconhece express√µes aritm√©ticas complexas
- N√£o suporta fun√ß√µes, escopos m√∫ltiplos ou tipos compostos
- Apenas aceita `int`, `float`, `if`, `while` e blocos b√°sicos

---

### üë®‚Äçüíª Aplica√ß√£o did√°tica

Ideal para introduzir conceitos de compiladores como:
- Tokens, gram√°tica e an√°lise sint√°tica recursiva
- Reconhecimento de erros l√©xicos e sint√°ticos
- Simula√ß√£o de parsing top-down

---

## üß† Introdu√ß√£o aos conceitos

### üßµ O que √© um compilador?

Um **compilador** √© um programa que traduz c√≥digo-fonte escrito em uma linguagem de programa√ß√£o de alto n√≠vel (como C, Java, Python) para uma linguagem de mais baixo n√≠vel (como c√≥digo de m√°quina ou bytecode).

Esse processo de tradu√ß√£o √© realizado em v√°rias etapas chamadas **fases da compila√ß√£o**, e o objetivo √© permitir que o computador entenda e execute o que foi escrito pelo programador.

Al√©m da tradu√ß√£o, um compilador pode detectar erros, realizar otimiza√ß√µes e gerar alertas sobre boas pr√°ticas. Ele √© composto por v√°rios m√≥dulos internos, como analisadores l√©xicos, sint√°ticos e sem√¢nticos.

---

# Conceitos b√°sicos de Linguagens e Express√µes Regulares

## üó£Ô∏è O que √© uma linguagem, uma gram√°tica e uma senten√ßa?

- **Linguagem de programa√ß√£o**: √â um conjunto de regras sint√°ticas e sem√¢nticas que definem como escrever programas. Exemplo: Python, C, Java.

- **Gram√°tica formal**: S√£o regras matem√°ticas que definem todas as senten√ßas v√°lidas de uma linguagem. Uma gram√°tica pode ser descrita como um conjunto de produ√ß√µes, que descrevem como formar frases v√°lidas.

  Exemplo de produ√ß√£o simplificada para declara√ß√£o de vari√°vel:
  ```
  DECLARACAO ‚Üí TIPO ID = NUMERO ;
  ```

- **Senten√ßa**: √â uma sequ√™ncia espec√≠fica de s√≠mbolos da linguagem. Uma senten√ßa pode estar ou n√£o correta segundo a gram√°tica.

  Exemplo de senten√ßa v√°lida (vers√£o 1):
  ```c
  int x = 42;
  ```

  Exemplo de senten√ßa inv√°lida (vers√£o 1):
  ```c
  int = x 42;
  ```

  Exemplo de senten√ßa v√°lida (vers√£o 2):
  ```c
    int x = 5;
    if (x > 0) {
        float y = 3.14;
    }
  ```

    Exemplo de senten√ßa inv√°lida (vers√£o 2):
  ```c
    int x = 5;
    if (x > 0) {
        float y = 3.14;
    
  ```

## üó£Ô∏è O que √© uma express√£o regular?

- **Express√£o regular**: Uma express√£o regular (ou regex, de regular expression) √© uma forma compacta de descrever padr√µes de texto. Ela permite que voc√™ procure, valide ou extraia partes de uma string com base em regras espec√≠ficas.

  Exemplo para uma m√°scara de telefone: Suponha que voc√™ queira verificar se uma string cont√©m um n√∫mero de telefone no formato (99) 9999-9999.

  ```python
  import re
  
  texto = "Meu telefone √© (11) 1234-5678"
  padrao = r"\(\d{2}\) \d{4}-\d{4}"
  resultado = re.search(padrao, texto)
  
  if resultado:
    print("N√∫mero encontrado:", resultado.group())
  ```

  Aqui, o padr√£o `\(\d{2}\) \d{4}-\d{4}` quer dizer:
  
  - `\(` e `\)` ‚Äî o par√™ntese literal;
  - `\d{2}` ‚Äî dois d√≠gitos (para o DDD);
  - espa√ßo;
  - `\d{4}` ‚Äî quatro d√≠gitos;
  - `-`;
  - `\d{4}` ‚Äî mais quatro d√≠gitos.

## ‚öôÔ∏è Como funciona o m√≥dulo `re` no Python?

A biblioteca `re` fornece fun√ß√µes para usar express√µes regulares, como:

- `re.search(padrao, texto)` ‚Äî procura o padr√£o em qualquer parte da string;
- `re.match(padrao, texto)` ‚Äî verifica se o padr√£o aparece no in√≠cio da string;
- `re.findall(padrao, texto)` ‚Äî retorna todas as ocorr√™ncias que combinam com o padr√£o;
- `re.sub(padrao, substituto, texto)` ‚Äî substitui partes do texto que combinam com o padr√£o;
- `re.compile(padrao)` ‚Äî compila o padr√£o para uso repetido, melhorando performance.

---

## Uso do `re` no analisador l√©xico deste projeto

No c√≥digo do analisador l√©xico, o `re` **transforma a string do c√≥digo-fonte em tokens** (unidades l√©xicas). Ele √© essencial para reconhecer padr√µes no texto do c√≥digo-fonte e transform√°-lo em tokens que o parser vai processar.

### üîç Passos principais ‚Äî Analisador L√©xico (Lexer)

1. **Defini√ß√£o dos padr√µes (`token_specification`)**

Cada token tem um nome e uma express√£o regular que define seu padr√£o no texto. Exemplos de tokens comuns:

| Nome do Token | Express√£o Regular         | Significado                                |
|---------------|---------------------------|--------------------------------------------|
| `'INT'`       | `r'int\b'`                | palavra-chave `int`                        |
| `'IF'`        | `r'if\b'`                 | palavra-chave `if`                         |
| `'ELSE'`      | `r'else\b'`               | palavra-chave `else`                       |
| `'WHILE'`     | `r'while\b'`              | palavra-chave `while`                      |
| `'RETURN'`    | `r'return\b'`             | palavra-chave `return`                     |
| `'ID'`        | `r'[a-zA-Z_]\w*'`         | identificadores (vari√°veis, nomes de fun√ß√µes etc.) |
| `'NUMBER'`    | `r'\d+(\.\d+)?'`          | n√∫meros inteiros ou decimais               |
| `'ASSIGN'`    | `r'='`                    | s√≠mbolo de atribui√ß√£o                      |
| `'EQ'`        | `r'=='`                   | igualdade l√≥gica                           |
| `'NEQ'`       | `r'!='`                   | diferen√ßa l√≥gica                           |
| `'LT'`        | `r'<'`                    | menor que                                  |
| `'GT'`        | `r'>'`                    | maior que                                  |
| `'PLUS'`      | `r'\+'`                   | adi√ß√£o                                     |
| `'MINUS'`     | `r'-'`                    | subtra√ß√£o                                  |
| `'MULT'`      | `r'\*'`                   | multiplica√ß√£o                              |
| `'DIV'`       | `r'/'`                    | divis√£o                                    |
| `'LPAREN'`    | `r'\('`                   | par√™ntese esquerdo                         |
| `'RPAREN'`    | `r'\)'`                   | par√™ntese direito                          |
| `'LBRACE'`    | `r'\{'`                   | chave esquerda                             |
| `'RBRACE'`    | `r'\}'`                   | chave direita                              |
| `'SEMICOLON'` | `r';'`                    | ponto e v√≠rgula                            |
| `'COMMENT'`   | `r'//.*'`                 | coment√°rios de linha                       |
| `'SKIP'`      | `r'[ \t]+'`               | espa√ßos e tabula√ß√µes (ignorados)           |
| `'NEWLINE'`   | `r'\n'`                   | quebra de linha (ignorada)                 |
| `'MISMATCH'`  | `r'.'`                    | caractere inv√°lido (gera erro l√©xico)      |

> üß† As palavras-chave precisam ser verificadas **antes** dos identificadores para evitar que `if` ou `while` sejam interpretados como `ID`.

---

2. **Combina√ß√£o das express√µes**

As express√µes s√£o unidas com o operador `|` (OU l√≥gico), usando **grupos nomeados**:

```python
token_regex = '|'.join(f'(?P<{name}>{pattern})' for name, pattern in token_specification)
```

Isso cria uma express√£o regular grande que reconhece qualquer tipo de token esperado.


3. **Extra√ß√£o dos tokens com `re.finditer`**

- Percorre o c√≥digo-fonte, encontrando cada trecho que bate com algum padr√£o.
- Identifica o tipo de token pelo grupo nomeado (`match.lastgroup`).
- Ignora espa√ßos, quebras de linha e lan√ßa erro para caracteres inv√°lidos.
- Retorna uma lista de tokens (tuplas do tipo e valor).

---

**Esse processo √© fundamental para converter o c√≥digo fonte em uma sequ√™ncia de tokens que o analisador sint√°tico pode entender e validar.**

### üßπ O que faz um Analisador L√©xico (Lexer)?

O **analisador l√©xico** √© a primeira etapa do compilador. Sua fun√ß√£o √© **ler o c√≥digo-fonte caractere por caractere** e **quebr√°-lo em tokens** ‚Äî unidades b√°sicas com significado, como palavras-chave, operadores, identificadores e n√∫meros.

### v1

Por exemplo, ao ler `int x = 42;`, o lexer pode produzir os seguintes tokens:

```
('INT', 'int')
('ID', 'x')
('ASSIGN', '=')
('NUMBER', '42')
('SEMICOLON', ';')
```

Se ele encontrar um caractere inesperado, como `@`, ele emite um erro l√©xico.

### v2

Expande os tokens da v1 com novos tipos:

- `'IF', 'ELSE', 'WHILE'`
- `'EQ': r'=='`, `'LT': r'<'`, `'GT': r'>'`
- Par√™nteses e chaves: `'LPAREN', 'RPAREN', 'LBRACE', 'RBRACE'`

---

### üß± O que faz um Analisador Sint√°tico (Parser)?

O **analisador sint√°tico** verifica se a sequ√™ncia de tokens obtida do lexer **segue as regras da gram√°tica da linguagem**.

Ou seja, ele n√£o apenas olha os peda√ßos individuais do c√≥digo (tokens), mas como eles est√£o **organizados**.

### v1

Por exemplo, ele reconhece que:

```c
int x = 42;
```

√© uma **declara√ß√£o v√°lida**, pois segue a estrutura:

```
TIPO ID = NUMERO ;
```

Mas:

```c
int x 42;
```

√© uma **declara√ß√£o inv√°lida**, pois est√° faltando o sinal de igual (`=`) e o ponto e v√≠rgula (`;`).

### v2

Suporta comandos condicionais e de repeti√ß√£o:

- Declara√ß√µes (`int x = 42;`)
- Estruturas condicionais `if (...) { ... }`
- La√ßos `while (...) { ... }`
- Blocos compostos com `{ }`

---

### üéì E o Analisador Sem√¢ntico?

O **analisador sem√¢ntico** (n√£o implementado neste projeto) √© uma etapa posterior √† an√°lise sint√°tica. Ele verifica **se a senten√ßa faz sentido no contexto da linguagem**.

Exemplos do que o analisador sem√¢ntico faria:

- Verificar se uma vari√°vel foi usada sem ter sido declarada.
- Verificar se h√° tentativa de atribuir um n√∫mero `float` a uma vari√°vel `int` sem convers√£o.
- Verificar se tipos de vari√°veis s√£o compat√≠veis em express√µes.

Enquanto o lexer e o parser verificam a forma (estrutura e sintaxe), o analisador sem√¢ntico verifica o **significado**.

---

## üíª Sa√≠da no Terminal

### ‚úÖ v1 - Senten√ßa v√°lida:

```
>>> C√≥digo fonte:
int x = 42;

>>> An√°lise l√©xica (tokens):
('INT', 'int')
('ID', 'x')
('ASSIGN', '=')
('NUMBER', '42')
('SEMICOLON', ';')

>>> An√°lise sint√°tica:
Declara√ß√£o v√°lida!
```

### ‚ùå v1 - Senten√ßa inv√°lida - Erro l√©xico (tem um @ em int@):

```
>>> C√≥digo fonte:
int@ x = 42;

>>> An√°lise l√©xica (tokens):
Erro l√©xico: Caractere inesperado: @
```

### ‚ùå v1 - Senten√ßa inv√°lida - Erro sint√°tico (falta ponto e v√≠rgula ao final da senten√ßa):

```
>>> C√≥digo fonte:
int x = 42

>>> An√°lise l√©xica (tokens):
('INT', 'int')
('ID', 'x')
('ASSIGN', '=')
('NUMBER', '42')

>>> An√°lise sint√°tica:
Erro sint√°tico: Esperado SEMICOLON, mas encontrei EOF
```

### ‚úÖ v2 - Senten√ßa v√°lida com if e bloco

```
>>> C√≥digo fonte:
int x = 5;
if (x > 0) {
    float y = 3.14;
}

>>> An√°lise l√©xica:
('INT', 'int') ('ID', 'x') ('ASSIGN', '=') ('NUMBER', '5') ('SEMICOLON', ';')
('IF', 'if') ('LPAREN', '(') ('ID', 'x') ('GT', '>') ('NUMBER', '0') ('RPAREN', ')')
('LBRACE', '{') ('FLOAT', 'float') ('ID', 'y') ('ASSIGN', '=') ('NUMBER', '3.14') ('SEMICOLON', ';') ('RBRACE', '}')

>>> An√°lise sint√°tica:
C√≥digo v√°lido!
```


### ‚ùå v2 - Senten√ßa inv√°lida com if e bloco

```
>>> C√≥digo fonte:
int x = 5;
if (x > 0) {
    float y = 3.14;

>>> An√°lise l√©xica (tokens):
('INT', 'int') ('ID', 'x') ('ASSIGN', '=') ('NUMBER', '5') ('SEMICOLON', ';')
('IF', 'if') ('LPAREN', '(') ('ID', 'x') ('GT', '>') ('NUMBER', '0') ('RPAREN', ')')
('LBRACE', '{') ('FLOAT', 'float') ('ID', 'y') ('ASSIGN', '=') ('NUMBER', '3.14') ('SEMICOLON', ';')

>>> An√°lise sint√°tica:
Erro sint√°tico: ("Esperado RBRACE, mas encontrei ('EOF')",)
```

---

## üì¶ Depend√™ncias

Nenhuma biblioteca externa √© necess√°ria. O projeto usa apenas a biblioteca padr√£o `re` para express√µes regulares.

---

## üß™ Ambiente Virtual (Recomendado)

### Passo 1: Criar e ativar o ambiente virtual

√â recomendado criar um ambiente virtual para isolar as depend√™ncias do projeto. Para configurar o ambiente virtual:

1. **Criar o ambiente virtual**:
   ```bash
   python -m venv venv
   ```

2. **Ativar o ambiente virtual**:
   - No Windows:
     ```bash
     .venv\Scripts\activate
     ```
   - No macOS/Linux:
     ```bash
     source venv/bin/activate
     ```

### Passo 2: Executar o script

Ap√≥s ativar o ambiente virtual, execute o script principal:
```bash
python minicompiler.py
```

---

## üìö Documenta√ß√£o e Links √öteis

- [Python re Module (docs)](https://docs.python.org/3/library/re.html)
- [Veja o material de compiladores do Prof. Aramuni aqui](https://github.com/joaopauloaramuni/compiladores/tree/main/PDF)
- [Livro recomendado: Compiladores - Princ√≠pios, T√©cnicas e Ferramentas (Dragon Book)](https://www.amazon.com.br/Compiladores-princ%C3%ADpios-ferramentas-Alfred-Aho/dp/8588639246/)

---

## ü™™ Licen√ßa

Este projeto est√° licenciado sob a **Licen√ßa MIT**.
